# Лабороторная работа №1
## Задание:
Получить разложение системы линейных уравнений в виде $Ax = b$ через $QR$ разложение и обратной подстановки.
## Решение
Выразить $A$ как $QR$, где $Q$ - ортогональная матрица, а $R$ - верхнетреугольная. Тогда $Ax = b$ превращается в $QRx = b$. Пользуясь ортогональностью $Q$ умножаем обе части на $Q$<sup>$T$</sup>, 
получаем $Q$<sup>$T$</sup>$QR$ = $Q$<sup>$T$</sup>$b$, а отсюда $R = Q$<sup>$T$</sub>$b$. Так-как $R$ - верхнетреугольная матрица, простой обратной подстановкой получаем решение системы.

Код можно открыть в папке labs или же по данной ссылке.

## Основные функции c объяснениями

### QR разложение
```python
def QR_Decomposition(A):
    n, m = A.shape

    Q = np.empty((n, min(n, m)))
    u = np.empty((n, min(n, m)))

    # Получаем первый нормированный и в будущем ортогональный вектор
    u[:, 0] = A[:, 0] 
    Q[:, 0] = u[:, 0] / np.linalg.norm(u[:, 0])

    for i in range(1, min(n, m)):

        u[:, i] = A[:, i]
        for j in range(i):
            # Вычитание из u проекции уже полученных "базисных" векторов
            u[:, i] -= (u[:, i] @ Q[:, j]) * Q[:, j] 

        Q[:, i] = u[:, i] / np.linalg.norm(u[:, i]) # Нормировка

    R = np.zeros((min(n, m), m))
    
    # for цикл для заполнения верхнетреугольной матрицы
    for i in range(min(n, m)):
        for j in range(i, m):
            R[i, j] = A[:, j] @ Q[:, i] # заполнение матрицы R

    return Q, R
```
#### Обратная подстановка
```python
def back_substitution(U, y): # Метод обратной подстановки

    n = U.shape[0] # Получение количества строк
    x = np.zeros_like(y, dtype=np.double); # Создаем массив для хранения решений

    x[-1] = y[-1] / U[-1, -1] # Считаем значение последнего аргумента(тривиальный случай)

    for i in range(n-2, -1, -1):
        # Идем с конца, вычитаем уже посчитанные значения помножив на коэффициенты, находим очередной элемент
        x[i] = (y[i] - np.dot(U[i,i:], x[i:])) / U[i,i] 

    return x
```

#### Получение решения
```python
Q, R = QR_Decomposition(A)
x = back_substitution(R, Q.T @ np.array([1.0, 1.0, 1.0])) # Пример вектора свободных коэффициентов, он может быть абсолютно другим
```

## Сравнение отличия полученного решения от ответа numpy
```python
x_np = np.linalg.solve(A, np.array([1.0, 1.0, 1.0]))
print(f"Difference: {np.linalg.norm(x - x_np)}")
```
1) Пример матрицы
2) 

